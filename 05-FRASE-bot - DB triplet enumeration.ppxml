<?xml version="1.0" encoding="UTF-8"?>
<sci:data xmlns:sci="http://www.SciTegic.com/" object="SciTegic.Protocol.1" format="8.0.0">
	<sci:dbitem>
		<sci:component name="05-FRASE-bot - DB triplet enumeration" version="2">
			<sci:arg name="Tempfiles" type="StringType" required="false" visibility="visible" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;A comma delimited list of global properties, each of which will automatically hold the name of a file in the job&apos;s temporary folder, whose name is guaranteed to be unique.&lt;/p&gt;

&lt;p&gt;For each global name, an additional global is created (with the suffix &lt;i&gt;_Filename&lt;/i&gt;) that hold just the leaf file name of the temporary file.&lt;/p&gt;</sci:help>
			</sci:arg>
			<sci:arg name="DeclareGlobal" type="StringType" required="false" visibility="visible" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;Lists a set of properties (without the @) to create on the global property list for this protocol. Such properties can be accessed within the scope of this protocol and its descendent subprotocols.&lt;p/&gt;

&lt;p&gt;It is best practice to declare all global properties before use. Indeed, this practice is enforced in some contexts.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;When a global property needs to be scoped to the whole protocol:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;List the new global property in the &lt;i&gt;DeclareGlobal&lt;/i&gt; parameter at the protocol level.&lt;/dd&gt;
&lt;br/&gt;
&lt;dt&gt;&lt;b&gt;To limit a global property to a subprotocol scope:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;List the property in the subprotocol&apos;s &lt;i&gt;DeclareLocal&lt;/i&gt; parameter.&lt;/dd&gt;

&lt;p&gt;This example declares 2 global properties:&lt;/p&gt;
&lt;pre&gt;
    g_tokenHash,g_assayIdentifier
&lt;/pre&gt;

&lt;p&gt;
To initialize the declared global value with a scalar value, use the syntax:
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;property-name&lt;/i&gt; := &lt;i&gt;value&lt;/i&gt;
&lt;/p&gt;
&lt;p&gt;
You can surround text string values with quotes to aid clarity. Values of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are handled as boolean values.
&lt;/p&gt;
&lt;p&gt;This example declares 3 global properties, and sets initial values on two of them:&lt;/p&gt;
&lt;pre&gt;
    g_counter := 0, g_location, g_geography:=&quot;APAC&quot;
&lt;/pre&gt;</sci:help>
			</sci:arg>
			<sci:arg name="Protocol Form" type="ProtocolType" required="false" visibility="visible" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;The path to a protocol that will render an HTML user interface for this protocol.  This optional parameter is used by Web Port to provide a custom user interface for a protocol.&lt;/p&gt;</sci:help>
			</sci:arg>
			<sci:arg name="Advanced Options" type="GroupType" required="false" visibility="visible" multi="false" expanded="true" legalvalsenforced="false" uimpl="true">
				<sci:member>__PoolID</sci:member>
				<sci:member>Http Cookie Handling</sci:member>
				<sci:member>__NotificationProtocol</sci:member>
			</sci:arg>
			<sci:arg name="__PoolID" type="StringType" required="false" visibility="visible" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;&lt;i&gt;__PoolID&lt;/i&gt; is a case insensitive string that can optionally be set to optimize the speed of execution for quick running protocols.  Multiple protocols with the same value for &lt;i&gt;__PoolID&lt;/i&gt; can share expensive resources such as database connections, Java VMs, memory, etc. reducing the execution time by 1 to 2 seconds per run.  This can give a large speed improvement to protocols that run in a few seconds such as web applications and interactive reports.  Longer running protocols will not see much benefit.  Generally, it is a good idea to use the same &lt;i&gt;__PoolID&lt;/i&gt; for all protocols within a single application such as an interactive report since many of the components, databases, and data structures will be similar.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;__PoolID&lt;/i&gt; can also be specified by the client when the protocol is launched.  If &lt;i&gt;__PoolID&lt;/i&gt; is specified both as a parameter by the client and as a parameter stored within the protocol, the client&apos;s value overrides the stored value.&lt;/p&gt;

&lt;p&gt;To disable pooling entirely for this particular protocol, set &lt;i&gt;__PoolID&lt;/i&gt; to &lt;b&gt;&amp;lt;Disable&amp;gt;&lt;/b&gt;&lt;/p&gt;</sci:help>
			</sci:arg>
			<sci:arg name="Http Cookie Handling" type="StringType" required="false" visibility="visible" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;&lt;i&gt;Http Cookie Handling&lt;/i&gt; provides a mechanism to control the handling of Http cookies within components that access remote resources via Http and Https.  These include the &lt;a href=&quot;javascript:DoLink(&apos;{8A25024A-C274-485B-BB99-8570DCC4C075}&apos;)&quot;&gt;HTTP Connector&lt;/a&gt;, Data readers such as &lt;a href=&quot;javascript:DoLink(&apos;{8056E8AD-33EA-42BB-9099-EAB24C3D08E6}&apos;)&quot;&gt;Text Reader&lt;/a&gt;, &lt;a href=&quot;javascript:DoLink(&apos;{93C4D73F-0B4D-03F4-B0E3-D82C4FE04C6F}&apos;)&quot;&gt;XML Reader (Generic)&lt;/a&gt;, etc., and custom Java, Perl, and .Net components that use the available APIs for accessing remote servers.  By default, New Protocols will have this setting enabled and set to &quot;Protocol Scope&quot;.  This means that Http cookies obtained from a remote server within any component in the protocol or any of its subprotocols will be parsed and appropriately sent back on subsequent requests from the same component or any other component.   The handling of the cookies is based on the IETF standard as specified in &lt;a href=&quot;javascript:DoLink(&apos;http://tools.ietf.org/html/rfc6265&apos;)&quot;&gt;http://tools.ietf.org/html/rfc6265&lt;/a&gt;.  Setting the parameter to Disabled will prevent components from parsing and returning cookies to the remote servers.&lt;/p&gt;

&lt;p&gt;Persistence of cookies is not supported, so scoping of Http cookies is entirely within the context of a single protocol execution.&lt;/p&gt;

&lt;p&gt;Older protocols that do not have the &lt;i&gt;Http Cookie Handling&lt;/i&gt; parameter will behave as though it had been set to &quot;Disabled&quot;.  To enable cookie handling in these protocols, copy this parameter from a New Protocol to the older protocol and set the parameter as desired.&lt;/p&gt;</sci:help>
				<sci:legalval selected="true">Protocol Scoped</sci:legalval>
				<sci:legalval>Disabled</sci:legalval>
			</sci:arg>
			<sci:arg name="__NotificationProtocol" type="StringType" required="false" visibility="visible" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;&lt;i&gt;__NotificationProtocol&lt;/i&gt; specifies the name or component ID (guid) of a protocol stored in the server&apos;s protocol database that will be executed when the current job completes. If your administrator has enabled notification protocols and depending on his or her preference, the notify protocol will either run as the anonymous user or as an admin specified user. The notification protocol receives several parameters that contain information about the original job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;i&gt;Notify_JobID&lt;/i&gt;: The job id of the execution
&lt;li&gt;&lt;i&gt;Notify_JobStatus&lt;/i&gt;: 
A description of the result of the job execution
&lt;li&gt;&lt;i&gt;Notify_JobStatusCode&lt;/i&gt;: The 
status code that for the result of the job execution.
	&lt;ul style=&quot;list-style-type:circle&quot;&gt;
	
&lt;li&gt;&lt;i&gt;5&lt;/i&gt;: Job was stopped by the client or administrator.
	&lt;li&gt;&lt;i&gt;6&lt;/i&gt;: 
Job completed normally with success.
	&lt;li&gt;&lt;i&gt;7&lt;/i&gt;: Job completed with an error.
	&lt;li&gt;&lt;i&gt;8&lt;/i&gt;: 
The process ID associated with the running job crashed or otherwise disappeared.
	&lt;li&gt;&lt;i&gt;9&lt;/i&gt;: 
Job failed to start.
	&lt;/ul&gt;
&lt;li&gt;&lt;i&gt;Notify_ProtocolName&lt;/i&gt;: The name of the protocol
&lt;li&gt;&lt;i&gt;Notify_ProtocolPath&lt;/i&gt;: 
The path of the protocol in the DB.  This field can be blank for protocols that were launched without 
saving to the database.
&lt;li&gt;&lt;i&gt;Notify_ProtocolLogName&lt;/i&gt;: The log name of the protocol.  
Is usually the same as ProtocolName, however this can be set by the client to a different name than the 
protocol.
&lt;li&gt;&lt;i&gt;Notify_RunHost&lt;/i&gt;: The name of the node where the protocol executed.
&lt;li&gt;&lt;i&gt;Notify_Username&lt;/i&gt;: 
The user that ran the job
&lt;/ul&gt;</sci:help>
			</sci:arg>
			<sci:arg name="Reporting" type="GroupType" required="false" visibility="visible" multi="false" expanded="true" uimpl="true">
				<sci:help>This group contains parameters specific to protocols containing Reporting components.</sci:help>
				<sci:member>Reporting Stylesheet</sci:member>
			</sci:arg>
			<sci:arg name="Reporting Stylesheet" type="StylesheetType" required="false" visibility="visible" multi="false" expanded="true" uimpl="true">
				<sci:help>Specifies the name of a Stylesheet to be used by this protocol if any of the Reporting components have a Style selected in the &lt;i&gt;Format&lt;/i&gt; and &lt;i&gt;Position&lt;/i&gt; parameters.</sci:help>
				<sci:value>{25A23C6A-4EF0-45F2-8495-3E88896C6262}</sci:value>
			</sci:arg>
			<sci:arg name="Run On Grid" type="BoolType" required="false" visibility="visible" multi="false" uimpl="true">
				<sci:help>The Run On Grid parameter tells the server to run the protocol on the grid engine if the Pipeline Pilot server is configured to run with grid integration.</sci:help>
				<sci:member>Queue Name</sci:member>
				<sci:member>Grid Options</sci:member>
				<sci:legalval>True</sci:legalval>
				<sci:legalval selected="true">False</sci:legalval>
			</sci:arg>
			<sci:arg name="Queue Name" type="StringType" required="false" visibility="visible" multi="false" legalvalsenforced="false" uimpl="true">
				<sci:help>The Queue Name allows you to specify the name of the queue on the grid engine to submit the job to. Leave blank to specify the default queue.</sci:help>
				<sci:enabledscript>parameter(&apos;Run On Grid&apos;);</sci:enabledscript>
			</sci:arg>
			<sci:arg name="Grid Options" type="StringType" required="false" visibility="visible" multi="true" legalvalsenforced="false" uimpl="true">
				<sci:help>&lt;p&gt;This is an array of command line options to send to the Grid engine submit command.&lt;/p&gt;
&lt;p&gt;If you just include one line, whatever you enter will be sent &quot;as is&quot; to the submission command.&lt;/p&gt;
&lt;/br&gt;
&lt;b&gt;Example - Just sending options directly to command line - PBS&lt;/b&gt;
&lt;p&gt;-l procs=16 -l walltime=08:00:00 -A PROJECTID&lt;/p&gt;
&lt;/br&gt;
&lt;p&gt;There are a number of parameters that Pipeline Pilot will translate to the correct command line options for whichever supported Grid Engine you are using.&lt;/p&gt;
&lt;/br&gt;
&lt;b&gt;Example - Supported parameters&lt;/b&gt;
&lt;p&gt;Account=&amp;lt;Project/Account name&amp;gt;&lt;/p&gt;
&lt;p&gt;Maximum Execution Time=&amp;lt;HH:MM:SS&amp;gt; hours, minutes, seconds - LSF ignores seconds&lt;/p&gt;
&lt;p&gt;Number of Cores=&amp;lt;16&amp;gt;&lt;/p&gt;
&lt;p&gt;Parallel Environment=&amp;lt;The Parallel Environment to use&amp;gt; - Only needed for SGE&lt;/p&gt;
&lt;p&gt;Other=&amp;lt;Additional Parameters sent directly to submit command line&amp;gt;&lt;/p&gt;
&lt;/br&gt;
&lt;p&gt;Any of these options can be commented out by placing a # in front of them.&lt;/p&gt;
&lt;/br&gt;
					</sci:help>
				<sci:enabledscript>parameter(&apos;Run On Grid&apos;);</sci:enabledscript>
				<sci:value>Account=</sci:value>
				<sci:value>Maximum Execution Time=</sci:value>
				<sci:value>Parallel Environment=</sci:value>
				<sci:value>Number of Cores=</sci:value>
				<sci:value>Other=</sci:value>
			</sci:arg>
			<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
				<sci:help>Component Attributes</sci:help>
				<sci:legalval>ComponentTakesInput</sci:legalval>
				<sci:legalval>ComponentReturnsPass</sci:legalval>
				<sci:legalval>ComponentReturnsFail</sci:legalval>
				<sci:legalval>ComponentRunsLocal</sci:legalval>
			</sci:arg>
			<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
				<sci:legalval selected="true">Halt</sci:legalval>
				<sci:legalval>Fail</sci:legalval>
				<sci:legalval>Pass</sci:legalval>
			</sci:arg>
			<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
				<sci:legalval selected="true">Halt</sci:legalval>
				<sci:legalval>Fail</sci:legalval>
				<sci:legalval>Pass</sci:legalval>
			</sci:arg>
			<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false"/>
			<sci:arg name="WebExports" type="StringType" required="false" visibility="nevershow" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;A comma delimited list of global properties which will be automatically 
exported if this protocol is published as a web service.&lt;/p&gt;

&lt;p&gt;Each global property in the list is created with an empty value at the start of the protocol run.&lt;/p&gt;</sci:help>
			</sci:arg>
			<sci:arg name="Keep Alive" type="BoolType" required="false" visibility="nevershow" multi="false" uimpl="true">
				<sci:help>&lt;p&gt;Specifies if the process where this protocol is run should stay around for later use.&lt;/p&gt;</sci:help>
				<sci:legalval selected="true">True</sci:legalval>
				<sci:legalval>False</sci:legalval>
			</sci:arg>
			<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:help>The user who registered this component.</sci:help>
				<sci:value>dkhf3</sci:value>
			</sci:arg>
			<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:help>The date this component was registered.</sci:help>
				<sci:value>Wed Jun 28 14:34:23 2023</sci:value>
			</sci:arg>
			<sci:arg name="RegistrationVersion" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:help>The server version when this component was registered</sci:help>
				<sci:value>23.1.100.97</sci:value>
			</sci:arg>
			<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:value>FRASE-bot db screening</sci:value>
			</sci:arg>
			<sci:arg name="ProtocolAutoLayout" type="BoolType" required="false" visibility="nevershow" multi="false">
				<sci:help>Protocol AutoLayout</sci:help>
				<sci:value>0</sci:value>
			</sci:arg>
			<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
				<sci:value>PROTOCOLNODE</sci:value>
			</sci:arg>
			<sci:arg name="ComponentRevision" type="LongType" required="true" visibility="nevershow" multi="false">
				<sci:help>Component Revision</sci:help>
				<sci:value>790</sci:value>
			</sci:arg>
			<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:value>{E9E2BD54-FFAC-45C4-A2AC-CBD5170FFC71}</sci:value>
			</sci:arg>
			<sci:arg name="ByReference" type="BoolType" required="false" visibility="nevershow" multi="false">
				<sci:help>By Ref</sci:help>
				<sci:value>0</sci:value>
			</sci:arg>
			<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
				<sci:value>100</sci:value>
				<sci:value>FRASE-bot db screening</sci:value>
				<sci:value/>
				<sci:value>None</sci:value>
				<sci:value/>
				<sci:value>None</sci:value>
				<sci:value/>
				<sci:value>None</sci:value>
				<sci:value/>
			</sci:arg>
			<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
			<sci:arg name="ProtocolScale2" type="LongType" required="false" visibility="nevershow" multi="false">
				<sci:help>Protocol Scale</sci:help>
				<sci:value>100</sci:value>
			</sci:arg>
			<sci:arg name="Protocol Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:help>Protocol Sticky Notes</sci:help>
			</sci:arg>
			<sci:arg name="Protocol Options" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:help>Protocol Options</sci:help>
				<sci:legalval>Owner Access Only</sci:legalval>
			</sci:arg>
			<sci:arg name="ResultFiles Options" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:value>Include JobDir Files</sci:value>
			</sci:arg>
			<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
				<sci:value>0</sci:value>
			</sci:arg>
			<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
				<sci:help>Local Component Identifier</sci:help>
				<sci:value>-1</sci:value>
			</sci:arg>
			<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:value>50 -50</sci:value>
			</sci:arg>
			<sci:arg name="OriginalPackage" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:help>OriginalPackage</sci:help>
				<sci:value>scitegic/coreutils</sci:value>
			</sci:arg>
			<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
				<sci:help>The original path within the database of this component.</sci:help>
				<sci:value>dkhf3\FRASE-bot\05-FRASE-bot - DB triplet enumeration</sci:value>
			</sci:arg>
		</sci:component>
		<sci:protocol>
			<sci:data object="SciTegic.MDLSDReader.1">
				<sci:component name="SD Reader" version="2">
					<sci:arg name="Source" type="URLType" required="true" visibility="visible" multi="false" expanded="true">
						<sci:help>The file or URL source to read</sci:help>
						<sci:member>Maximum</sci:member>
						<sci:member>SourceTag</sci:member>
						<sci:member>Keep Properties</sci:member>
						<sci:member>UTF-8 Auto Detect</sci:member>
						<sci:value>userdata:/BindingDB_All_2D_actives-w-3d-FRASE.sdf.gz</sci:value>
					</sci:arg>
					<sci:arg name="Maximum" type="LongType" required="false" visibility="visible" multi="false">
						<sci:help>The maximum number of data records to read (all if value is empty)</sci:help>
					</sci:arg>
					<sci:arg name="SourceTag" type="StringType" required="true" visibility="visible" multi="false">
						<sci:help>&lt;p&gt;The type of tag to create to identify the source of data records. A property called 
&lt;b&gt;SourceTag&lt;/b&gt; is created and holds the value indicated.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;None&lt;/b&gt;: 
No SourceTag property is created and any existing ones are removed.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Filename&lt;/b&gt;: 
The name of the file read.&lt;/li&gt;&lt;li&gt;&lt;b&gt;FilenameAndExtension&lt;/b&gt;: The name of the 
file read with its file extension.&lt;/li&gt;&lt;li&gt;&lt;b&gt;FullFilename&lt;/b&gt;: The name of the 
file read, including the directory path.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ZipFilename&lt;/b&gt;: When reading 
a compressed zip file, the filename within the compressed archive.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Number&lt;/b&gt;: 
When multiple files are read in this component, they are numbered 1,2,3...&lt;/li&gt;&lt;li&gt;&lt;b&gt;Letter&lt;/b&gt;: 
When multiple files are read in this component, they are lettered A, B, C...&lt;/li&gt;&lt;li&gt;&lt;b&gt;KeepCurrent&lt;/b&gt;: 
Keeps the current value of SourceTag.&lt;/li&gt;&lt;/ul&gt;</sci:help>
						<sci:legalval selected="true">None</sci:legalval>
						<sci:legalval>Filename</sci:legalval>
						<sci:legalval>FilenameAndExtension</sci:legalval>
						<sci:legalval>FullFilename</sci:legalval>
						<sci:legalval>ZipFilename</sci:legalval>
						<sci:legalval>Number</sci:legalval>
						<sci:legalval>Letter</sci:legalval>
						<sci:legalval>KeepCurrent</sci:legalval>
					</sci:arg>
					<sci:arg name="Keep Properties" type="PropertyPreviewType" required="false" visibility="visible" multi="false">
						<sci:help>A list of properties the reader should retain for each data record that is output. If a value is not defined, retains all properties. If the parameter contains the value &quot;-&quot; (minus sign), properties are not retained.</sci:help>
					</sci:arg>
					<sci:arg name="UTF-8 Auto Detect" type="BoolType" required="false" visibility="visible" multi="false" legalvalsenforced="false" uimpl="false">
						<sci:help>&lt;p&gt;UTF-8 is a type of character encoding used to represent international characters with multiple bytes whereas basic Latin characters remain as a single byte.  Files can be stored with a Byte Order Mark (BOM) to indicate that the type of character encoding.&lt;/p&gt;
&lt;p&gt;When reading files that do not have a BOM, this parameter allows the reader to attempt to automatically detect UTF-8 encodings and convert as needed.  However, be aware that automatic detection is not always reliable.  In some cases, valid text stored in different character encodings can appear to be valid UTF-8.  In these cases, the automatic detection will result in garbled text.  When this occurs, you can consider using the &lt;a href=&quot;javascript:DoLink(&apos;{B0B1B56C-3DF6-444C-BB78-B43211188F63}&apos;)&quot;&gt;Binary Reader&lt;/a&gt; to read the file, then converting using the Pilotscript function &lt;b&gt;ConvertBytesToString&lt;/b&gt;&lt;/p&gt;</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="Additional Options" type="GroupType" required="false" visibility="visible" multi="false" expanded="true" legalvalsenforced="false">
						<sci:help>Contains less commonly used parameters</sci:help>
						<sci:member>ReadProperties</sci:member>
						<sci:member>PutNameInProperty</sci:member>
						<sci:member>ReadQueryInfo</sci:member>
						<sci:member>PutCommentInProperty</sci:member>
						<sci:member>SD Format Options</sci:member>
						<sci:member>Global Templates</sci:member>
					</sci:arg>
					<sci:arg name="SD Format Options" type="StringType" required="false" visibility="visible" multi="true">
						<sci:help>&lt;p&gt;Options available for the SD Reader:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Properties Can Contain $$$$:&lt;/b&gt;  By the CTFile standard, a property can contain a &apos;$$$$&apos;-line.  
Properties or data field values are terminated by a blank line.  Only then will the &apos;$$$$&apos;-line 
terminate the full data block.  Setting this option off will terminate the data block upon any read of 
a &apos;$$$$&apos;-line.  This option is available to provide compatibility with some 3rd Party SD files.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;One-space Lines Terminate Properties:&lt;/b&gt;  By the CTFile standard, properties or data fields values are 
terminated by a blank line. Selecting this option will terminate the data block when encountering a line 
containing a space as the only character in the line.  This option is available to provide compatibility 
with some 3rd Party SD files.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Unwrap Long Property Lines:&lt;/b&gt;  By the CTFile standard, lines in property fields cannot exceed 200 characters.  When this option is selected and a property line of exactly 200 characters is found, the newline character will be ignored and property string will continue on the next line.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Read Unknown Stereo Parity:&lt;/b&gt;  When selected, the SD Reader will use the &apos;Atom Parity&apos; value (parity of 
&apos;3&apos;) to mark unknown stereo centers in 3D mol files.  This will leave these atoms marked as 
&apos;unknown stereo&apos; and will not calculate the stereo from the coordinates.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Process Complex Data Header Lines:&lt;/b&gt; Data header lines are the lines in the SD format that precede the actual data. They can contain the data field name (enclosed in angular brackets &lt;&gt;), the data field number (as DTn), the external registry number (enclosed in parentheses), and other optional information. When this parameter is set to False, only the data field name is parsed and used to set the corresponding property name. All the other information in the line is ignored. When the parameter is set to true, all the information is parsed. The property name is set from either the field name in &lt;&gt; or the DTn. If both are present the field name takes priority and the DTn number is saved as an additional property named &lt;b&gt;FieldName#DTn&lt;/b&gt;. The external registry number is saved as &lt;b&gt;FieldName#ExtRegNum&lt;/b&gt; and any other information is saved as &lt;b&gt;FieldName#OtherDataFieldInfo&lt;/b&gt;. When the molecules are written to an SD file, the data header lines are reconstructed from these properties. The default state of this parameter is False, as parsing, preserving, and eventually writing all the information in the data header lines can be costly, specially for SD files with many data fields.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Convert From H2 And H+ Atom Types:&lt;/b&gt; &apos;H2&apos; and &apos;H+&apos; are two non-standard element types that can be assigned to atoms by the BIOVIA Draw sketcher. They represent unattached Hydrogen (a Hydrogen molecule) and charged Hydrogen (a proton), respectively. When this parameter is selected, these atom types are converted to standard hydrogen atoms upon reading, with charges of 0 for H2 and +1 for H+. Otherwise, these atoms are read and perceived as unknown atom types, with &apos;H2&apos; and &apos;H+&apos; as the atom labels.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Convert Radicals To Pi Systems:&lt;/b&gt; When selected, pi bonds will be perceived between adjacent atoms marked with radicals and any adjacent metal atom.  Once pi bonds are perceived, subsequent exports will represent the pi bonds using the V3000 format and one-to-many coordination bonds (type 9) unless the writer&apos;s &lt;i&gt;Convert Pi Systems To Radicals&lt;/i&gt; option is used to convert the pi systems back. &lt;/li&gt;
&lt;li&gt;&lt;b&gt;Convert GEN+DAT to Polymer Repeat Units:&lt;/b&gt; When selected, this option will automatically convert input GEN sgroups with linked DAT sgroups having the special fieldname of &apos;rc&apos; and numeric or numeric range data internally into polymer repeat sgroups.  This usage is a special type of NONS (Non-Specific Structure) convention that was prototyped in previous releases.  Disabling this conversion will have a higher likelihood of producing a structure that can be registered into Direct databases. &lt;/li&gt;
&lt;li&gt;&lt;b&gt;Always Keep Enhanced Stereo:&lt;/b&gt; Preserves any enhanced stereo collections that are read in from V3000 MOL file.  When disabled, stereo structures will be checked to see if they can be represented more simply using only the Chiral Flag.  That is, structures with only ABS centers can be represented without enhanced stereo by setting the Chiral Flag on and structures with all centers in a single AND group can be represented without enhanced stereo by setting the Chiral Flag off.  Enhanced stereo collections that do not fit into the above cases are always preserved.&lt;/li&gt;
&lt;/ul&gt;</sci:help>
						<sci:legalval selected="true">Properties Can Contain $$$$</sci:legalval>
						<sci:legalval>One-space Lines Terminate Properties</sci:legalval>
						<sci:legalval selected="true">Unwrap Long Property Lines</sci:legalval>
						<sci:legalval>Read Unknown Stereo Parity</sci:legalval>
						<sci:legalval>Process Complex Data Header Lines</sci:legalval>
						<sci:legalval selected="true">Convert From H2 And H+ Atom Types</sci:legalval>
						<sci:legalval>Convert Radicals To Pi Systems</sci:legalval>
						<sci:legalval selected="true">Convert GEN+DAT to Polymer Repeat Units</sci:legalval>
						<sci:legalval>Always Keep Enhanced Stereo</sci:legalval>
					</sci:arg>
					<sci:arg name="ReadProperties" type="BoolType" required="true" visibility="visible" multi="false">
						<sci:help>Select True to read the properties for each molecule (in addition to the structures)</sci:help>
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="ReadQueryInfo" type="BoolType" required="true" visibility="visible" multi="false">
						<sci:help>If properties starting with &quot;QueryInfo&quot; are present, use them to set up query information on the atoms and bonds. (This is how, for example, SMARTS query information can be preserved when writing to an SD format file.) For molecules saved in MOL/SD format, this information only contains information that cannot be written out in the connection table.</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="PutNameInProperty" type="StringType" required="false" visibility="visible" multi="false">
						<sci:help>What to call the property that holds the name of each molecule</sci:help>
						<sci:value>Name</sci:value>
					</sci:arg>
					<sci:arg name="PutCommentInProperty" type="StringType" required="false" visibility="visible" multi="false" expanded="true">
						<sci:help>What to call the property that holds the comment associated with each molecule</sci:help>
					</sci:arg>
					<sci:arg name="Global Templates" type="URLType" required="false" visibility="visible" multi="false">
						<sci:help>V3000 SD or MOL files containing template definitions for amino acid, nucleic acid or other residues or monomers. These templates can then be refered to by molecules read by the SD reader.&lt;p&gt;
The default template file included in the Chemistry collection, &lt;i&gt;data\Direct\Direct_templates.mol&lt;/i&gt; contains definitions for 22 amino acids and 8 DNA and RNA templates.</sci:help>
						<sci:value>data\HELM\SCSRtemplates.mol</sci:value>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval>ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="HasConvertPiSystemOption" type="BoolType" required="false" visibility="nevershow" multi="false" legalvalsenforced="false">
						<sci:help>Hidden flag specifying the presence of the &quot;Convert Radicals To Pi Systems&quot; option.</sci:help>
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="AllowUnknownDoubleBondsFromCoordinates" type="BoolType" required="false" visibility="nevershow" multi="false">
						<sci:help>According to the CTfile specifications, the cis/trans character of double bonds with bond stereo set to zero is determined from the coordinates. This parameter controls whether or not to assign unknown bond stereo to double bonds for which the stereo could not be determined from the coordinates, either because there are no coordinates or because of colinearity issues.  When the parameter is set to False and the stereo could not be determined, no specific stereo configuration is assigned to the double bond, but it is not marked as unknown stereo.</sci:help>
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/chemistry</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Wed Apr 06 11:41:13 2016</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>SD Reader</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>DOCUMENTNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{CA65B896-4FE6-4E3A-B884-DC16B53B8D26}</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon.</sci:help>
						<sci:value>SD Reader</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>90 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Reads MOL (molecule CTAB) files and SD (structured data) files</sci:value>
						<sci:value>&lt;p&gt;Creates a molecular data record for each molecule represented in the &lt;i&gt;Source&lt;/i&gt; 
data file.  All properties contained in the file are read into the data records.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;&lt;p&gt;&lt;ul&gt;&lt;li&gt;This 
component can also read zipped (.zip) and URL-based files.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;See 
Also:&lt;/b&gt;&lt;p&gt;&lt;ul&gt;&lt;li&gt;To write files in MOL or SD format, use the &lt;a href=&quot;javascript:DoLink(&apos;{DC8EE7B0-0620-42FE-944C-B4CD1E79480E}&apos;)&quot;&gt;SD 
Writer&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;To convert a molecule to and from between text properties in CTAB 
format, use &lt;a href=&quot;javascript:DoLink(&apos;{E622FBD9-9FA9-451A-A102-1800B5F28B6D}&apos;)&quot;&gt;Molecule 
to CTAB&lt;/a&gt; and &lt;a href=&quot;javascript:DoLink(&apos;{7D354B65-DDD8-4EA4-83A7-21501A8A6852}&apos;)&quot;&gt;Molecule 
from CTAB&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Other related CTFile format file readers include &lt;a href=&quot;javascript:DoLink(&apos;{169AB4E5-A470-477B-AA65-50464411036C}&apos;)&quot;&gt;RG 
Reader&lt;/a&gt;, &lt;a href=&quot;javascript:DoLink(&apos;{036731AA-0015-4606-9750-7D9D020F21C8}&apos;)&quot;&gt;RXN 
Reader&lt;/a&gt; and &lt;a href=&quot;javascript:DoLink(&apos;{55431CCB-06EA-4741-B95B-633C877E3E9B}&apos;)&quot;&gt;RD 
Reader&lt;/a&gt;.&lt;/li&gt; &lt;/ul&gt;</sci:value>
						<sci:value>None</sci:value>
						<sci:value/>
						<sci:value>Molecule</sci:value>
						<sci:value>Data fields in the SD file will be added to the property fields</sci:value>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="RegistrationVersion" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The server version when this component was registered</sci:help>
						<sci:value>17.1.0.59</sci:value>
					</sci:arg>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Chemistry\Data Access and Manipulation\Readers\SD Reader</sci:value>
					</sci:arg>
				</sci:component>
			</sci:data>
			<sci:data object="SciTegic.EvaluateExpression.1">
				<sci:component name="Custom Filter (PilotScript)" version="2">
					<sci:arg name="Expression" type="ExpressionType" required="true" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>The PilotScript expression used to filter the data.</sci:help>
						<sci:member>Initial Expression</sci:member>
						<sci:member>Final Expression</sci:member>
						<sci:member>Keep Calculated Properties</sci:member>
						<sci:value>molecular_weight &lt; 10000</sci:value>
					</sci:arg>
					<sci:arg name="Initial Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>&lt;p&gt;
An expression evaluated only when the component
is first initialized (when the first data record enters).
&lt;p/&gt;
Since there is no data available at initialization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Final Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>&lt;p&gt;
An expression evaluated only when the
component is finalized (once the last data
record has passed).
&lt;p/&gt;
Since there is no data available at finalization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Keep Calculated Properties" type="BoolType" required="true" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>Allows any properties that were calculated in
&quot;Expression&quot; to be included with the exiting
record.
Otherwise, these properties are removed after
the evaluation is complete.</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an expected data type is not found during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an recoverable error occurs during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>Custom Error Message</sci:help>
					</sci:arg>
					<sci:arg name="ExpressionVersion" type="LongType" required="false" visibility="nevershow" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>Version of expression parser to use.</sci:help>
						<sci:value>2</sci:value>
					</sci:arg>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/generic</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Mon Jan 21 09:57:16 2008</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>custom</sci:value>
					</sci:arg>
					<sci:arg name="ComponentAutoDisplayName" type="ExpressionType" required="false" visibility="nevershow" multi="false">
						<sci:help>Automatically update the component display name when the &quot;Expression&quot; property is changed. This feature is turned off after the user manually changes the display name of the component in Protocol workspace.</sci:help>
						<sci:value>#displayName := trim(Parameter(&apos;Expression&apos;, 2));
if(strlength(#displayName) &gt; 0) then	
	/* Find the first line break */
	#nl := FindSubstring(#displayName, &quot;\r&quot;);
	if #nl &lt;= 0 then
		#nl := FindSubstring(#displayName, &quot;\n&quot;);
	end if;

	/* Keep the first line only */
	if (#nl &gt; 0) then
		StrErase(#displayName, #nl);
	end if;
	
	#displayName;
else
	&quot;&quot;;
end if;</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>FILTERNODE</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon.</sci:help>
						<sci:value>Custom Filter (PilotScript)</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{DD58ECD1-516F-48FE-A5DB-8328AED680F2}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>378 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Passes data records for which a PilotScript expression evaluates to True

</sci:value>
						<sci:value>&lt;p&gt;For each incoming data record, the PilotScript statements in &lt;i&gt;Expression&lt;/i&gt; are evaluated. If the last statement in the expression evaluates to True or non-zero, the record is sent out the Pass port. Otherwise it is sent out the Fail port.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Notes:&lt;/b&gt;
&lt;ul&gt;
&lt;li&gt;To initialize global variables such as counters, use &lt;i&gt;Initial Expression&lt;/i&gt;.&lt;/li&gt; 
&lt;li&gt;To clean up global variables or calculate final results use &lt;i&gt;Final Expression&lt;/i&gt;.&lt;/li&gt;
&lt;li&gt;Parameters on Custom Manipulators do not become global variables that can be accessed via &lt;i&gt;@ParameterName&lt;/i&gt; syntax.  They must be accessed by using the &lt;i&gt;Parameter(&apos;ParameterName&apos;)&lt;/i&gt; function or by using token substitution via &lt;i&gt;$(ParameterName)&lt;/i&gt; syntax.&lt;/li&gt;
&lt;/ul&gt;
&lt;/ul&gt;
</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>Generic</sci:value>
						<sci:value>Data records for which the final expression in the PilotScript evaluates to True or non-zero</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value>Data records for which the final expression in the PilotScript evaluates to False or zero</sci:value>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>63</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Data Access and Manipulation\Property Filters\Custom Filter (PilotScript)</sci:value>
					</sci:arg>
				</sci:component>
				<sci:proplist>
					<sci:propval name="RegistrationVersion">7.0.0.35</sci:propval>
				</sci:proplist>
			</sci:data>
			<sci:data object="SciTegic.EvaluateExpression.1">
				<sci:component name="Custom Manipulator (PilotScript)" version="2">
					<sci:arg name="Expression" type="ExpressionType" required="true" visibility="visible" multi="false" expanded="true" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Expression (or list of expressions separated by semi-colons) to evaluate.</sci:help>
						<sci:member>Initial Expression</sci:member>
						<sci:member>Final Expression</sci:member>
						<sci:member>Keep Calculated Properties</sci:member>
						<sci:value>ResidueCode:=ResCode;
#mind := 10; // Min edge size in a triangle
#maxd := 12; // Max edge size in a triangle
resize(d,0);
#ti := 0;
resize(t,0);
for #i in 1 .. Numvalues(ResCaXYZ)
loop
	#first := #i;
	#second := 0;
	#third := 0;
	if ResidueCode[#i] ne &apos;X&apos; then
		#xyzi := ResCaXYZ[#i];
		expand(&apos;,&apos;,#xyzi);
		for #j in #i .. Numvalues(ResCaXYZ)
		loop
			if (ResidueCode[#j] ne &apos;X&apos;) and (#i ne #j) then
				#xyzj := ResCaXYZ[#j];
				expand(&apos;,&apos;,#xyzj);
				#dij := sqrt(power(#xyzj[1]-#xyzi[1],2)+power(#xyzj[2]-#xyzi[2],2)+power(#xyzj[3]-#xyzi[3],2));
				if #dij &gt;= #mind and #dij &lt;= #maxd then
					#second := #j;
					for #k in #j .. Numvalues(ResCaXYZ)
					loop
						if (ResidueCode[#k] ne &apos;X&apos;) and (#j ne #k) then
							#xyzk := ResCaXYZ[#k];
							expand(&apos;,&apos;,#xyzk);
							#dik := sqrt(power(#xyzi[1]-#xyzk[1],2)+power(#xyzi[2]-#xyzk[2],2)+power(#xyzi[3]-#xyzk[3],2));
							#djk := sqrt(power(#xyzj[1]-#xyzk[1],2)+power(#xyzj[2]-#xyzk[2],2)+power(#xyzj[3]-#xyzk[3],2));
							if #dik &gt;= #mind and #dik &lt;= #maxd and #djk &gt;= #mind and #djk &lt;= #maxd then 
								#third := #k;
								if #first ne 0 and #second ne 0 and #third ne 0 then
									Append(t_1, #first . &apos;,&apos; . #second . &apos;,&apos; . #third);
									Append(t_f_xyz_1, ResCaXYZ[#first] . &apos;,&apos; . ResCaXYZ[#second] . &apos;,&apos; . ResCaXYZ[#third]);
									Append(t_2, #first . &apos;,&apos; . #third . &apos;,&apos; . #second);
									Append(t_f_xyz_2, ResCaXYZ[#first] . &apos;,&apos; . ResCaXYZ[#third] . &apos;,&apos; . ResCaXYZ[#second]);
									Append(t_3, #second . &apos;,&apos; . #first . &apos;,&apos; . #third);
									Append(t_f_xyz_3, ResCaXYZ[#second] . &apos;,&apos; . ResCaXYZ[#first] . &apos;,&apos; . ResCaXYZ[#third]);
									Append(t_4, #second . &apos;,&apos; . #third . &apos;,&apos; . #first);
									Append(t_f_xyz_4, ResCaXYZ[#second] . &apos;,&apos; . ResCaXYZ[#third] . &apos;,&apos; . ResCaXYZ[#first]);
									Append(t_5, #third . &apos;,&apos; . #first . &apos;,&apos; . #second);
									Append(t_f_xyz_5, ResCaXYZ[#third] . &apos;,&apos; . ResCaXYZ[#first] . &apos;,&apos; . ResCaXYZ[#second]);
									Append(t_6, #third . &apos;,&apos; . #second . &apos;,&apos; . #first);
									Append(t_f_xyz_6, ResCaXYZ[#third] . &apos;,&apos; . ResCaXYZ[#second] . &apos;,&apos; . ResCaXYZ[#first]);
									#nres := #first;
									#ionpos:=&apos;0,&apos;;#ionneg:=&apos;0,&apos;;#hba:=&apos;0,&apos;;#hbd:=&apos;0,&apos;;#ar:=&apos;0,&apos;;#hy:=&apos;0,0,0,&apos;;#vol:=&apos;0,0,0&apos;;
									if (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#ionpos := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) then
										#ionneg := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#hba := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#hbd := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#ar := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;G&apos;) then
										#hy := &apos;0,0,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;A&apos;) OR (ResidueCode[#nres] eq &apos;P&apos;) then
										#hy := &apos;1,0,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;V&apos;) OR (ResidueCode[#nres] eq &apos;I&apos;) OR (ResidueCode[#nres] eq &apos;L&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) then
										#hy := &apos;1,1,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;M&apos;) OR (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#hy := &apos;1,1,1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;G&apos;) then
										#vol := &apos;0,0,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;A&apos;) OR (ResidueCode[#nres] eq &apos;P&apos;) then
										#vol := &apos;1,0,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;V&apos;) OR (ResidueCode[#nres] eq &apos;I&apos;) OR (ResidueCode[#nres] eq &apos;L&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#vol := &apos;1,1,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;M&apos;) OR (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) OR (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) then
										#vol := &apos;1,1,1&apos;;
									end if;
									#first_fp := #ionpos . #ionneg . #hba . #hbd . #ar . #hy . #vol;
									#nres := #second;
									#ionpos:=&apos;0,&apos;;#ionneg:=&apos;0,&apos;;#hba:=&apos;0,&apos;;#hbd:=&apos;0,&apos;;#ar:=&apos;0,&apos;;#hy:=&apos;0,0,0,&apos;;#vol:=&apos;0,0,0&apos;;
									if (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#ionpos := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) then
										#ionneg := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#hba := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#hbd := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#ar := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;G&apos;) then
										#hy := &apos;0,0,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;A&apos;) OR (ResidueCode[#nres] eq &apos;P&apos;) then
										#hy := &apos;1,0,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;V&apos;) OR (ResidueCode[#nres] eq &apos;I&apos;) OR (ResidueCode[#nres] eq &apos;L&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) then
										#hy := &apos;1,1,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;M&apos;) OR (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#hy := &apos;1,1,1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;G&apos;) then
										#vol := &apos;0,0,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;A&apos;) OR (ResidueCode[#nres] eq &apos;P&apos;) then
										#vol := &apos;1,0,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;V&apos;) OR (ResidueCode[#nres] eq &apos;I&apos;) OR (ResidueCode[#nres] eq &apos;L&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#vol := &apos;1,1,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;M&apos;) OR (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) OR (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) then
										#vol := &apos;1,1,1&apos;;
									end if;
									#second_fp := #ionpos . #ionneg . #hba . #hbd . #ar . #hy . #vol;
									#nres := #third;
									#ionpos:=&apos;0,&apos;;#ionneg:=&apos;0,&apos;;#hba:=&apos;0,&apos;;#hbd:=&apos;0,&apos;;#ar:=&apos;0,&apos;;#hy:=&apos;0,0,0,&apos;;#vol:=&apos;0,0,0&apos;;
									if (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#ionpos := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) then
										#ionneg := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#hba := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#hbd := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#ar := &apos;1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;G&apos;) then
										#hy := &apos;0,0,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;A&apos;) OR (ResidueCode[#nres] eq &apos;P&apos;) then
										#hy := &apos;1,0,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;V&apos;) OR (ResidueCode[#nres] eq &apos;I&apos;) OR (ResidueCode[#nres] eq &apos;L&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) then
										#hy := &apos;1,1,0,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;M&apos;) OR (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) then
										#hy := &apos;1,1,1,&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;G&apos;) then
										#vol := &apos;0,0,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;A&apos;) OR (ResidueCode[#nres] eq &apos;P&apos;) then
										#vol := &apos;1,0,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;V&apos;) OR (ResidueCode[#nres] eq &apos;I&apos;) OR (ResidueCode[#nres] eq &apos;L&apos;) OR (ResidueCode[#nres] eq &apos;T&apos;) OR (ResidueCode[#nres] eq &apos;C&apos;) OR (ResidueCode[#nres] eq &apos;S&apos;) OR (ResidueCode[#nres] eq &apos;N&apos;) OR (ResidueCode[#nres] eq &apos;D&apos;) OR (ResidueCode[#nres] eq &apos;H&apos;) then
										#vol := &apos;1,1,0&apos;;
									end if;
									if (ResidueCode[#nres] eq &apos;M&apos;) OR (ResidueCode[#nres] eq &apos;F&apos;) OR (ResidueCode[#nres] eq &apos;Y&apos;) OR (ResidueCode[#nres] eq &apos;W&apos;) OR (ResidueCode[#nres] eq &apos;R&apos;) OR (ResidueCode[#nres] eq &apos;K&apos;) OR (ResidueCode[#nres] eq &apos;E&apos;) OR (ResidueCode[#nres] eq &apos;Q&apos;) then
										#vol := &apos;1,1,1&apos;;
									end if;
									#third_fp := #ionpos . #ionneg . #hba . #hbd . #ar . #hy . #vol;
									Append(t_fp_1, #first_fp . &apos;,&apos; . #second_fp . &apos;,&apos; . #third_fp);
									Append(t_fp_2, #first_fp . &apos;,&apos; . #third_fp . &apos;,&apos; . #second_fp);
									Append(t_fp_3, #second_fp . &apos;,&apos; . #first_fp . &apos;,&apos; . #third_fp);
									Append(t_fp_4, #second_fp . &apos;,&apos; . #third_fp . &apos;,&apos; . #first_fp);
									Append(t_fp_5, #third_fp . &apos;,&apos; . #first_fp . &apos;,&apos; . #second_fp);
									Append(t_fp_6, #third_fp . &apos;,&apos; . #second_fp . &apos;,&apos; . #first_fp);
								end if;
							end if;
						end if;
						resize(#xyzk,0);
					end loop;
				end if;
				resize(#xyzj,0);
			end if;
		end loop;
		resize(#xyzi,0);
	end if;
end loop;
Keep(&apos;FRASE_ID&apos;,&apos;t_1&apos;,&apos;t_f_xyz_1&apos;,&apos;t_2&apos;,&apos;t_f_xyz_2&apos;,&apos;t_3&apos;,&apos;t_f_xyz_3&apos;,&apos;t_4&apos;,&apos;t_f_xyz_4&apos;,&apos;t_5&apos;,&apos;t_f_xyz_5&apos;,&apos;t_6&apos;,&apos;t_f_xyz_6&apos;,&apos;t_fp_1&apos;,&apos;t_fp_2&apos;,&apos;t_fp_3&apos;,&apos;t_fp_4&apos;,&apos;t_fp_5&apos;,&apos;t_fp_6&apos;);

/*
resize(#center_t,3);
#center_t[1] := 0;
#center_t[2] := 0;
#center_t[3] := 0;
for #i in 1 .. Numvalues(t)
loop
	#ti := t[#i];
	expand(&apos;,&apos;,#ti);
	for #j in 1 .. 3
	loop
		#xyzi := ResCaXYZ[#ti[#j]];
		expand(&apos;,&apos;,#xyzi);
		#center_t[1] := #center_t[1] + #xyzi[1];
		#center_t[2] := #center_t[2] + #xyzi[2];
		#center_t[3] := #center_t[3] + #xyzi[3];
	end loop;
end loop;
#center_t[1] := #center_t[1] / (Numvalues(t)*3);
#center_t[2] := #center_t[2] / (Numvalues(t)*3);
#center_t[3] := #center_t[3] / (Numvalues(t)*3);
mean_dtc := 0;
for #i in 1 .. Numvalues(t)
loop
	#ti := t[#i];
	expand(&apos;,&apos;,#ti);
	for #j in 1 .. 3
	loop
		#xyzi := ResCaXYZ[#ti[#j]];
		expand(&apos;,&apos;,#xyzi);
		#dtc := sqrt(power(#xyzi[1]-#center_t[1],2)+power(#xyzi[2]-#center_t[2],2)+power(#xyzi[3]-#center_t[3],2));
		mean_dtc := mean_dtc + #dtc;
	end loop;
end loop;
mean_dtc := mean_dtc / (Numvalues(t)*3);
*/
</sci:value>
					</sci:arg>
					<sci:arg name="Initial Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>&lt;p&gt;
This expression is executed only the first time data passes into the component.
&lt;p/&gt; 
Since there is no data available at initialization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Final Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>&lt;p&gt;
This expression is executed only at finalization (after the last data passes out of the component).
&lt;p/&gt; 
Since there is no data available at finalization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Keep Calculated Properties" type="BoolType" required="true" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Adds any properties calculated in this component to a data record&apos;s property list.</sci:help>
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an expected data type is not found during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an recoverable error occurs during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>Custom Error Message</sci:help>
					</sci:arg>
					<sci:arg name="Do Screen" type="BoolType" required="false" visibility="nevershow" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>When TRUE, controls which exit port is used for
each data record by evaluating the final expression
(or only one) listed in the &quot;Expression&quot; parameter.
   -Pass (green) port when expression true
   -Fail (red) port when expression false</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="ExpressionVersion" type="LongType" required="false" visibility="nevershow" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Version of expression parser to use.</sci:help>
						<sci:value>2</sci:value>
					</sci:arg>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/generic</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Mon Jan 21 09:55:43 2008</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>generate FRASE triplets</sci:value>
					</sci:arg>
					<sci:arg name="ComponentAutoDisplayName" type="ExpressionType" required="false" visibility="nevershow" multi="false">
						<sci:help>Automatically update the component display name when the &quot;Expression&quot; property is changed. This feature is turned off after the user manually changes the display name of the component in Protocol workspace.</sci:help>
						<sci:value>#displayName := trim(Parameter(&apos;Expression&apos;, 2));
if(strlength(#displayName) &gt; 0) then	
	/* Find the first line break */
	#nl := FindSubstring(#displayName, &quot;\r&quot;);
	if #nl &lt;= 0 then
		#nl := FindSubstring(#displayName, &quot;\n&quot;);
	end if;

	/* Keep the first line only */
	if (#nl &gt; 0) then
		StrErase(#displayName, #nl);
	end if;
	
	#displayName;
else
	&quot;&quot;;
end if;</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon.</sci:help>
						<sci:value>Custom Manipulator (PilotScript)</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>EXPRESSIONNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{0995D675-7EE2-432C-95DF-E91C14052B22}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>666 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Applies a PilotScript expression to each data record
</sci:value>
						<sci:value>&lt;p&gt;PilotScript is the native scripting language in Pipeline Pilot.  It is based on PL/SQL and allows you to query or alter the properties on data records.  For example, the expression:

&lt;blockquote&gt;
&lt;code&gt;A := 10;&lt;/code&gt;
&lt;/blockquote&gt;
creates a property named &quot;A&quot; and sets the value to &quot;10&quot;.&lt;/p&gt;

&lt;p&gt;For each incoming data record the PilotScript statements in &lt;i&gt;Expression&lt;/i&gt; are evaluated.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Notes:&lt;/b&gt;
&lt;ul&gt;
&lt;li&gt;To initialize global variables such as counters, use &lt;i&gt;Initial Expression&lt;/i&gt;.&lt;/li&gt; 
&lt;li&gt;To clean up global variables or calculate final results use &lt;i&gt;Final Expression&lt;/i&gt;.&lt;/li&gt;
&lt;li&gt;Parameters on Custom Manipulators do not become global variables that can be accessed via &lt;i&gt;@ParameterName&lt;/i&gt; syntax.  They must be accessed by using the &lt;i&gt;Parameter(&apos;ParameterName&apos;)&lt;/i&gt; function or by using token substitution via &lt;i&gt;$(ParameterName)&lt;/i&gt; syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;See Also:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For more information on PilotScript, see &lt;a href=&quot;javascript:DoLink(&apos;scihelpdocs/user/pscript/pscript_overview.htm&apos;)&quot;&gt;PilotScript Overview&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;To use PilotScript to filter data records use &lt;a href=&quot;javascript:DoLink(&apos;{DD58ECD1-516F-48FE-A5DB-8328AED680F2}&apos;)&quot;&gt;Custom Filter (PilotScript)&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="RegistrationVersion" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The server version when this component was registered</sci:help>
						<sci:value>7.0.0.35</sci:value>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>1</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Data Access and Manipulation\Property Manipulators\Custom Manipulator (PilotScript)</sci:value>
					</sci:arg>
				</sci:component>
			</sci:data>
			<sci:data object="SciTegic.EvaluateExpression.1">
				<sci:component name="Custom Filter (PilotScript)" version="2">
					<sci:arg name="Expression" type="ExpressionType" required="true" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>The PilotScript expression used to filter the data.</sci:help>
						<sci:member>Initial Expression</sci:member>
						<sci:member>Final Expression</sci:member>
						<sci:member>Keep Calculated Properties</sci:member>
						<sci:value>t_1 is defined and Numvalues(t_1) &gt; 0</sci:value>
					</sci:arg>
					<sci:arg name="Initial Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>&lt;p&gt;
An expression evaluated only when the component
is first initialized (when the first data record enters).
&lt;p/&gt;
Since there is no data available at initialization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Final Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>&lt;p&gt;
An expression evaluated only when the
component is finalized (once the last data
record has passed).
&lt;p/&gt;
Since there is no data available at finalization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Keep Calculated Properties" type="BoolType" required="true" visibility="visible" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>Allows any properties that were calculated in
&quot;Expression&quot; to be included with the exiting
record.
Otherwise, these properties are removed after
the evaluation is complete.</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an expected data type is not found during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an recoverable error occurs during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>Custom Error Message</sci:help>
					</sci:arg>
					<sci:arg name="ExpressionVersion" type="LongType" required="false" visibility="nevershow" multi="false" implbase="{DD58ECD1-516F-48FE-A5DB-8328AED680F2}">
						<sci:help>Version of expression parser to use.</sci:help>
						<sci:value>2</sci:value>
					</sci:arg>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/generic</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Mon Jan 21 09:57:16 2008</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>custom</sci:value>
					</sci:arg>
					<sci:arg name="ComponentAutoDisplayName" type="ExpressionType" required="false" visibility="nevershow" multi="false">
						<sci:help>Automatically update the component display name when the &quot;Expression&quot; property is changed. This feature is turned off after the user manually changes the display name of the component in Protocol workspace.</sci:help>
						<sci:value>#displayName := trim(Parameter(&apos;Expression&apos;, 2));
if(strlength(#displayName) &gt; 0) then	
	/* Find the first line break */
	#nl := FindSubstring(#displayName, &quot;\r&quot;);
	if #nl &lt;= 0 then
		#nl := FindSubstring(#displayName, &quot;\n&quot;);
	end if;

	/* Keep the first line only */
	if (#nl &gt; 0) then
		StrErase(#displayName, #nl);
	end if;
	
	#displayName;
else
	&quot;&quot;;
end if;</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>FILTERNODE</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon.</sci:help>
						<sci:value>Custom Filter (PilotScript)</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{DD58ECD1-516F-48FE-A5DB-8328AED680F2}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>978 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Passes data records for which a PilotScript expression evaluates to True

</sci:value>
						<sci:value>&lt;p&gt;For each incoming data record, the PilotScript statements in &lt;i&gt;Expression&lt;/i&gt; are evaluated. If the last statement in the expression evaluates to True or non-zero, the record is sent out the Pass port. Otherwise it is sent out the Fail port.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Notes:&lt;/b&gt;
&lt;ul&gt;
&lt;li&gt;To initialize global variables such as counters, use &lt;i&gt;Initial Expression&lt;/i&gt;.&lt;/li&gt; 
&lt;li&gt;To clean up global variables or calculate final results use &lt;i&gt;Final Expression&lt;/i&gt;.&lt;/li&gt;
&lt;li&gt;Parameters on Custom Manipulators do not become global variables that can be accessed via &lt;i&gt;@ParameterName&lt;/i&gt; syntax.  They must be accessed by using the &lt;i&gt;Parameter(&apos;ParameterName&apos;)&lt;/i&gt; function or by using token substitution via &lt;i&gt;$(ParameterName)&lt;/i&gt; syntax.&lt;/li&gt;
&lt;/ul&gt;
&lt;/ul&gt;
</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>Generic</sci:value>
						<sci:value>Data records for which the final expression in the PilotScript evaluates to True or non-zero</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value>Data records for which the final expression in the PilotScript evaluates to False or zero</sci:value>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>2</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Data Access and Manipulation\Property Filters\Custom Filter (PilotScript)</sci:value>
					</sci:arg>
				</sci:component>
				<sci:proplist>
					<sci:propval name="RegistrationVersion">7.0.0.35</sci:propval>
				</sci:proplist>
			</sci:data>
			<sci:data object="SciTegic.SeparateValues.1">
				<sci:component name="Unmerge Data" version="2">
					<sci:arg name="PropertyNames" type="PropertyNameType" required="false" visibility="visible" multi="false">
						<sci:help>&lt;p&gt;The names of the one or more properties to separate and return as separate data records.  If no property names are given, then all properties with
multiple values will be unmerged. If multiple properties are unmerged, the number of unmerged records is the number of values of a property with the maximum number of values.</sci:help>
					</sci:arg>
					<sci:arg name="Additional Options" type="StringType" required="false" visibility="visible" multi="false">
						<sci:help>Contains less commonly used parameters</sci:help>
						<sci:member>Large Data Records</sci:member>
						<sci:member>Unmerge ByteArrayValues</sci:member>
					</sci:arg>
					<sci:arg name="Large Data Records" type="BoolType" required="false" visibility="visible" multi="false">
						<sci:help>When individual data records are very large as may be the case with Images, Sequence Analysis or Gene Expression Data, or Text Analytics annotations, this component can easily run out of memory on 32-bit systems.  If each of your records are particularly large, setting this parameter to true will significantly reduce the memory usage of the component but with the tradeoff of slower performance.</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="Unmerge ByteArrayValues" type="BoolType" required="false" visibility="visible" multi="false" legalvalsenforced="false">
						<sci:help>ByteArrayValues are property representations of binary data.  Although they are technically arrays of bytes and could be unmerged, in most cases these properties should be treated as a single value rather than an array of bytes.  This parameter is available to restore the previous odd behavior, if desired.</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/generic</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Tue Sep 13 07:08:33 2016</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>Unmerge Data</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>Unmerge Data</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>GENERATORNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{5E28C170-2FEC-4A3C-90A6-2DCEAA330E9D}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>1266 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Separates data records containing array properties into individual records with one array value per record</sci:value>
						<sci:value>&lt;p&gt;Each incoming data record with more than one value for the property or properties specified by &lt;i&gt;PropertyNames&lt;/i&gt; is duplicated for each of the values.  For example, an input data record with three values will generate three output data records.  Each output record will contain one of the values for the &lt;i&gt;PropertyNames&lt;/i&gt; property, and all other properties will be identical.&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Large Data Records&lt;/i&gt;: When individual data records are very large as may be the case with Images, Sequence Analysis or Gene Expression Data, or Text Analytics annotations, this component can easily run out of memory on 32-bit systems.  If each data record is particularly large, setting &lt;i&gt;Large Data Records&lt;/i&gt; to true will significantly reduce the memory usage of the component but with the tradeoff of slower performance.&lt;/p&gt;


&lt;b&gt;Notes:&lt;/b&gt;
&lt;ul&gt;
&lt;li&gt;If no property names are given, then all properties with multiple values are unmerged.  In this case, unexpected occurrences of arrays in a property will cause unintentional unmerge operations.  Try to specify a value for &lt;i&gt;PropertyNames&lt;/i&gt; if possible.&lt;/li&gt;
&lt;li&gt;If multiple unmerge properties are specified, the number of data records that result from unmerging a given incoming data record is equal to the number of values of the unmerge property that has the most values.  That is, if two unmerge properties, &quot;A&quot; and &quot;B&quot; are specified where A has 5 values and B has 7 values, then 7 data records will result.  The first 5 records will contain, in order, the 5 values of A.  For the last two records, A will be undefined.  All other properties will be duplicated on each record.&lt;/li&gt;
&lt;/ul&gt;
</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>Generic</sci:value>
						<sci:value>Data records containing the separated values for the property or properties specified.</sci:value>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>10</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Data Access and Manipulation\Data Manipulators\Unmerge Data</sci:value>
					</sci:arg>
				</sci:component>
				<sci:proplist>
					<sci:propval name="RegistrationVersion">17.1.0.119</sci:propval>
				</sci:proplist>
			</sci:data>
			<sci:data object="SciTegic.EvaluateExpression.1">
				<sci:component name="Custom Manipulator (PilotScript)" version="2">
					<sci:arg name="Expression" type="ExpressionType" required="true" visibility="visible" multi="false" expanded="true" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Expression (or list of expressions separated by semi-colons) to evaluate.</sci:help>
						<sci:member>Initial Expression</sci:member>
						<sci:member>Final Expression</sci:member>
						<sci:member>Keep Calculated Properties</sci:member>
						<sci:value>Resize(t,0);
Append(t,t_1);
/*
Append(t,t_2);
Append(t,t_3);
Append(t,t_4);
Append(t,t_5);
Append(t,t_6);
*/
Remove(&apos;t_1&apos;,&apos;t_2&apos;,&apos;t_3&apos;,&apos;t_4&apos;,&apos;t_5&apos;,&apos;t_6&apos;);
Resize(t_fp,0);
Append(t_fp,t_fp_1);
/*
Append(t_fp,t_fp_2);
Append(t_fp,t_fp_3);
Append(t_fp,t_fp_4);
Append(t_fp,t_fp_5);
Append(t_fp,t_fp_6);
*/
Remove(&apos;t_fp_1&apos;,&apos;t_fp_2&apos;,&apos;t_fp_3&apos;,&apos;t_fp_4&apos;,&apos;t_fp_5&apos;,&apos;t_fp_6&apos;);
Resize(t_f_xyz,0);
Append(t_f_xyz,t_f_xyz_1);
/*
Append(t_f_xyz,t_f_xyz_2);
Append(t_f_xyz,t_f_xyz_3);
Append(t_f_xyz,t_f_xyz_4);
Append(t_f_xyz,t_f_xyz_5);
Append(t_f_xyz,t_f_xyz_6);
*/
Remove(&apos;t_f_xyz_1&apos;,&apos;t_f_xyz_2&apos;,&apos;t_f_xyz_3&apos;,&apos;t_f_xyz_4&apos;,&apos;t_f_xyz_5&apos;,&apos;t_f_xyz_6&apos;);
</sci:value>
					</sci:arg>
					<sci:arg name="Initial Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>&lt;p&gt;
This expression is executed only the first time data passes into the component.
&lt;p/&gt; 
Since there is no data available at initialization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Final Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>&lt;p&gt;
This expression is executed only at finalization (after the last data passes out of the component).
&lt;p/&gt; 
Since there is no data available at finalization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Keep Calculated Properties" type="BoolType" required="true" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Adds any properties calculated in this component to a data record&apos;s property list.</sci:help>
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an expected data type is not found during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an recoverable error occurs during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>Custom Error Message</sci:help>
					</sci:arg>
					<sci:arg name="Do Screen" type="BoolType" required="false" visibility="nevershow" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>When TRUE, controls which exit port is used for
each data record by evaluating the final expression
(or only one) listed in the &quot;Expression&quot; parameter.
   -Pass (green) port when expression true
   -Fail (red) port when expression false</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="ExpressionVersion" type="LongType" required="false" visibility="nevershow" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Version of expression parser to use.</sci:help>
						<sci:value>2</sci:value>
					</sci:arg>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/generic</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Mon Jan 21 09:55:43 2008</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>prep</sci:value>
					</sci:arg>
					<sci:arg name="ComponentAutoDisplayName" type="ExpressionType" required="false" visibility="nevershow" multi="false">
						<sci:help>Automatically update the component display name when the &quot;Expression&quot; property is changed. This feature is turned off after the user manually changes the display name of the component in Protocol workspace.</sci:help>
						<sci:value>#displayName := trim(Parameter(&apos;Expression&apos;, 2));
if(strlength(#displayName) &gt; 0) then	
	/* Find the first line break */
	#nl := FindSubstring(#displayName, &quot;\r&quot;);
	if #nl &lt;= 0 then
		#nl := FindSubstring(#displayName, &quot;\n&quot;);
	end if;

	/* Keep the first line only */
	if (#nl &gt; 0) then
		StrErase(#displayName, #nl);
	end if;
	
	#displayName;
else
	&quot;&quot;;
end if;</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon.</sci:help>
						<sci:value>Custom Manipulator (PilotScript)</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>EXPRESSIONNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{0995D675-7EE2-432C-95DF-E91C14052B22}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>1578 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Applies a PilotScript expression to each data record
</sci:value>
						<sci:value>&lt;p&gt;PilotScript is the native scripting language in Pipeline Pilot.  It is based on PL/SQL and allows you to query or alter the properties on data records.  For example, the expression:

&lt;blockquote&gt;
&lt;code&gt;A := 10;&lt;/code&gt;
&lt;/blockquote&gt;
creates a property named &quot;A&quot; and sets the value to &quot;10&quot;.&lt;/p&gt;

&lt;p&gt;For each incoming data record the PilotScript statements in &lt;i&gt;Expression&lt;/i&gt; are evaluated.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Notes:&lt;/b&gt;
&lt;ul&gt;
&lt;li&gt;To initialize global variables such as counters, use &lt;i&gt;Initial Expression&lt;/i&gt;.&lt;/li&gt; 
&lt;li&gt;To clean up global variables or calculate final results use &lt;i&gt;Final Expression&lt;/i&gt;.&lt;/li&gt;
&lt;li&gt;Parameters on Custom Manipulators do not become global variables that can be accessed via &lt;i&gt;@ParameterName&lt;/i&gt; syntax.  They must be accessed by using the &lt;i&gt;Parameter(&apos;ParameterName&apos;)&lt;/i&gt; function or by using token substitution via &lt;i&gt;$(ParameterName)&lt;/i&gt; syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;See Also:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For more information on PilotScript, see &lt;a href=&quot;javascript:DoLink(&apos;scihelpdocs/user/pscript/pscript_overview.htm&apos;)&quot;&gt;PilotScript Overview&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;To use PilotScript to filter data records use &lt;a href=&quot;javascript:DoLink(&apos;{DD58ECD1-516F-48FE-A5DB-8328AED680F2}&apos;)&quot;&gt;Custom Filter (PilotScript)&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="RegistrationVersion" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The server version when this component was registered</sci:help>
						<sci:value>7.0.0.35</sci:value>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>12</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Data Access and Manipulation\Property Manipulators\Custom Manipulator (PilotScript)</sci:value>
					</sci:arg>
				</sci:component>
			</sci:data>
			<sci:data object="SciTegic.SeparateValues.1">
				<sci:component name="Unmerge Data" version="2">
					<sci:arg name="PropertyNames" type="PropertyNameType" required="false" visibility="visible" multi="false">
						<sci:help>&lt;p&gt;The names of the one or more properties to separate and return as separate data records.  If no property names are given, then all properties with
multiple values will be unmerged. If multiple properties are unmerged, the number of unmerged records is the number of values of a property with the maximum number of values.</sci:help>
					</sci:arg>
					<sci:arg name="Additional Options" type="StringType" required="false" visibility="visible" multi="false">
						<sci:help>Contains less commonly used parameters</sci:help>
						<sci:member>Large Data Records</sci:member>
						<sci:member>Unmerge ByteArrayValues</sci:member>
					</sci:arg>
					<sci:arg name="Large Data Records" type="BoolType" required="false" visibility="visible" multi="false">
						<sci:help>When individual data records are very large as may be the case with Images, Sequence Analysis or Gene Expression Data, or Text Analytics annotations, this component can easily run out of memory on 32-bit systems.  If each of your records are particularly large, setting this parameter to true will significantly reduce the memory usage of the component but with the tradeoff of slower performance.</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="Unmerge ByteArrayValues" type="BoolType" required="false" visibility="visible" multi="false" legalvalsenforced="false">
						<sci:help>ByteArrayValues are property representations of binary data.  Although they are technically arrays of bytes and could be unmerged, in most cases these properties should be treated as a single value rather than an array of bytes.  This parameter is available to restore the previous odd behavior, if desired.</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/generic</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Tue Sep 13 07:08:33 2016</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>Unmerge Data</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>Unmerge Data</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>GENERATORNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{5E28C170-2FEC-4A3C-90A6-2DCEAA330E9D}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>1866 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Separates data records containing array properties into individual records with one array value per record</sci:value>
						<sci:value>&lt;p&gt;Each incoming data record with more than one value for the property or properties specified by &lt;i&gt;PropertyNames&lt;/i&gt; is duplicated for each of the values.  For example, an input data record with three values will generate three output data records.  Each output record will contain one of the values for the &lt;i&gt;PropertyNames&lt;/i&gt; property, and all other properties will be identical.&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Large Data Records&lt;/i&gt;: When individual data records are very large as may be the case with Images, Sequence Analysis or Gene Expression Data, or Text Analytics annotations, this component can easily run out of memory on 32-bit systems.  If each data record is particularly large, setting &lt;i&gt;Large Data Records&lt;/i&gt; to true will significantly reduce the memory usage of the component but with the tradeoff of slower performance.&lt;/p&gt;


&lt;b&gt;Notes:&lt;/b&gt;
&lt;ul&gt;
&lt;li&gt;If no property names are given, then all properties with multiple values are unmerged.  In this case, unexpected occurrences of arrays in a property will cause unintentional unmerge operations.  Try to specify a value for &lt;i&gt;PropertyNames&lt;/i&gt; if possible.&lt;/li&gt;
&lt;li&gt;If multiple unmerge properties are specified, the number of data records that result from unmerging a given incoming data record is equal to the number of values of the unmerge property that has the most values.  That is, if two unmerge properties, &quot;A&quot; and &quot;B&quot; are specified where A has 5 values and B has 7 values, then 7 data records will result.  The first 5 records will contain, in order, the 5 values of A.  For the last two records, A will be undefined.  All other properties will be duplicated on each record.&lt;/li&gt;
&lt;/ul&gt;
</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>Generic</sci:value>
						<sci:value>Data records containing the separated values for the property or properties specified.</sci:value>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>13</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Data Access and Manipulation\Data Manipulators\Unmerge Data</sci:value>
					</sci:arg>
				</sci:component>
				<sci:proplist>
					<sci:propval name="RegistrationVersion">17.1.0.119</sci:propval>
				</sci:proplist>
			</sci:data>
			<sci:data object="SciTegic.EvaluateExpression.1">
				<sci:component name="Custom Manipulator (PilotScript)" version="2">
					<sci:arg name="Expression" type="ExpressionType" required="true" visibility="visible" multi="false" expanded="true" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Expression (or list of expressions separated by semi-colons) to evaluate.</sci:help>
						<sci:member>Initial Expression</sci:member>
						<sci:member>Final Expression</sci:member>
						<sci:member>Keep Calculated Properties</sci:member>
						<sci:value>Expand(&apos;,&apos;,t_fp);
</sci:value>
					</sci:arg>
					<sci:arg name="Initial Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>&lt;p&gt;
This expression is executed only the first time data passes into the component.
&lt;p/&gt; 
Since there is no data available at initialization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Final Expression" type="ExpressionType" required="false" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>&lt;p&gt;
This expression is executed only at finalization (after the last data passes out of the component).
&lt;p/&gt; 
Since there is no data available at finalization time, only expressions referencing local or global properties are allowed.
&lt;/p&gt;</sci:help>
					</sci:arg>
					<sci:arg name="Keep Calculated Properties" type="BoolType" required="true" visibility="visible" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Adds any properties calculated in this component to a data record&apos;s property list.</sci:help>
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an expected data type is not found during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:help>When an recoverable error occurs during processing:  
  Halt: Terminate the execution of the network
  Fail: Continue execution of the network, passing data out the Fail(red) port
  Pass: Continue execution of the network, passing data out the Pass(green) port</sci:help>
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>Custom Error Message</sci:help>
					</sci:arg>
					<sci:arg name="Do Screen" type="BoolType" required="false" visibility="nevershow" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>When TRUE, controls which exit port is used for
each data record by evaluating the final expression
(or only one) listed in the &quot;Expression&quot; parameter.
   -Pass (green) port when expression true
   -Fail (red) port when expression false</sci:help>
						<sci:legalval>True</sci:legalval>
						<sci:legalval selected="true">False</sci:legalval>
					</sci:arg>
					<sci:arg name="ExpressionVersion" type="LongType" required="false" visibility="nevershow" multi="false" implbase="{0995D675-7EE2-432C-95DF-E91C14052B22}">
						<sci:help>Version of expression parser to use.</sci:help>
						<sci:value>2</sci:value>
					</sci:arg>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/generic</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Mon Jan 21 09:55:43 2008</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>prep</sci:value>
					</sci:arg>
					<sci:arg name="ComponentAutoDisplayName" type="ExpressionType" required="false" visibility="nevershow" multi="false">
						<sci:help>Automatically update the component display name when the &quot;Expression&quot; property is changed. This feature is turned off after the user manually changes the display name of the component in Protocol workspace.</sci:help>
						<sci:value>#displayName := trim(Parameter(&apos;Expression&apos;, 2));
if(strlength(#displayName) &gt; 0) then	
	/* Find the first line break */
	#nl := FindSubstring(#displayName, &quot;\r&quot;);
	if #nl &lt;= 0 then
		#nl := FindSubstring(#displayName, &quot;\n&quot;);
	end if;

	/* Keep the first line only */
	if (#nl &gt; 0) then
		StrErase(#displayName, #nl);
	end if;
	
	#displayName;
else
	&quot;&quot;;
end if;</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon.</sci:help>
						<sci:value>Custom Manipulator (PilotScript)</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>EXPRESSIONNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{0995D675-7EE2-432C-95DF-E91C14052B22}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>2178 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Applies a PilotScript expression to each data record
</sci:value>
						<sci:value>&lt;p&gt;PilotScript is the native scripting language in Pipeline Pilot.  It is based on PL/SQL and allows you to query or alter the properties on data records.  For example, the expression:

&lt;blockquote&gt;
&lt;code&gt;A := 10;&lt;/code&gt;
&lt;/blockquote&gt;
creates a property named &quot;A&quot; and sets the value to &quot;10&quot;.&lt;/p&gt;

&lt;p&gt;For each incoming data record the PilotScript statements in &lt;i&gt;Expression&lt;/i&gt; are evaluated.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Notes:&lt;/b&gt;
&lt;ul&gt;
&lt;li&gt;To initialize global variables such as counters, use &lt;i&gt;Initial Expression&lt;/i&gt;.&lt;/li&gt; 
&lt;li&gt;To clean up global variables or calculate final results use &lt;i&gt;Final Expression&lt;/i&gt;.&lt;/li&gt;
&lt;li&gt;Parameters on Custom Manipulators do not become global variables that can be accessed via &lt;i&gt;@ParameterName&lt;/i&gt; syntax.  They must be accessed by using the &lt;i&gt;Parameter(&apos;ParameterName&apos;)&lt;/i&gt; function or by using token substitution via &lt;i&gt;$(ParameterName)&lt;/i&gt; syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;See Also:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For more information on PilotScript, see &lt;a href=&quot;javascript:DoLink(&apos;scihelpdocs/user/pscript/pscript_overview.htm&apos;)&quot;&gt;PilotScript Overview&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;To use PilotScript to filter data records use &lt;a href=&quot;javascript:DoLink(&apos;{DD58ECD1-516F-48FE-A5DB-8328AED680F2}&apos;)&quot;&gt;Custom Filter (PilotScript)&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

</sci:value>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>Generic</sci:value>
						<sci:value/>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="RegistrationVersion" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The server version when this component was registered</sci:help>
						<sci:value>7.0.0.35</sci:value>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>14</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Data Access and Manipulation\Property Manipulators\Custom Manipulator (PilotScript)</sci:value>
					</sci:arg>
				</sci:component>
			</sci:data>
			<sci:data object="SciTegic.ConvertFingerprint.1">
				<sci:component name="Convert Fingerprint" version="2">
					<sci:arg name="Property Name" type="StringType" required="true" visibility="visible" multi="false" expanded="true">
						<sci:help>The name of the property that will contain the source fingerprint information</sci:help>
						<sci:member>Input Format</sci:member>
						<sci:value>t_fp</sci:value>
					</sci:arg>
					<sci:arg name="Input Format" type="StringType" required="true" visibility="visible" multi="false">
						<sci:help>The expected format of the input property. Available formats are:
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Bitset&lt;/b&gt;: a bitset or a list of on bits as text, such as &quot;3 4 5&quot;.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Binary String&lt;/b&gt;: a string such as &quot;0010011&quot;.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Hex String&lt;/b&gt;: a string such as &quot;3FD54FF&quot;.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Array of Bits&lt;/b&gt;: an array of zeros and ones.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Array of Counts&lt;/b&gt;: an array of zeros and counts.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Base64&lt;/b&gt;: a Base64-encoded string of bits.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Daylight Base64&lt;/b&gt;: a Daylight Base64-encoded string of bits.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;List of Integer Bits&lt;/b&gt; (&lt;i&gt;SciTegic fingerprint format&lt;/i&gt;): an array of the &quot;on&quot; bits.&lt;/li&gt; 
&lt;li&gt;&lt;b&gt;List of Floating-Point Bits&lt;/b&gt;: an array of floating-point numbers.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;List of String Bits&lt;/b&gt;: an array of strings.&lt;/li&gt;
&lt;/ul&gt;
</sci:help>
						<sci:legalval>Fixed-Length Bitset</sci:legalval>
						<sci:legalval>Fixed-Length Binary String</sci:legalval>
						<sci:legalval>Fixed-Length Hex String</sci:legalval>
						<sci:legalval selected="true">Fixed-Length Array of Bits</sci:legalval>
						<sci:legalval>Fixed-Length Array of Counts</sci:legalval>
						<sci:legalval>Fixed-Length Base64</sci:legalval>
						<sci:legalval>Fixed-Length Daylight Base64</sci:legalval>
						<sci:legalval>List of Integer Bits</sci:legalval>
						<sci:legalval>List of Floating-Point Bits</sci:legalval>
						<sci:legalval>List of String Bits</sci:legalval>
					</sci:arg>
					<sci:arg name="Output Property Name" type="StringType" required="false" visibility="visible" multi="false" expanded="true">
						<sci:help>The name of the property to save the converted fingerprint into. If left blank, the input property will be overwritten.</sci:help>
						<sci:member>Output Fixed Length</sci:member>
						<sci:member>Output Bit Order</sci:member>
						<sci:member>Output Format</sci:member>
					</sci:arg>
					<sci:arg name="Output Format" type="StringType" required="true" visibility="visible" multi="false">
						<sci:help>&lt;p&gt;The desired format for the output property. Available formats are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Bitset&lt;/b&gt;: a bitset or a list of on bits as text, such as &quot;3 4 5&quot;.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Binary String&lt;/b&gt;: a string such as &quot;0010011&quot;.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Hex String&lt;/b&gt;: a string such as &quot;3FD54FF&quot;.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Array of Bits&lt;/b&gt;: an array of zeros and ones.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Array of Counts&lt;/b&gt;: an array of zeros and counts.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Base64&lt;/b&gt;: a Base64-encoded string of bits.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Fixed-Length Daylight Base64&lt;/b&gt;: a Daylight Base64-encoded string of bits.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;List of Integer Bits&lt;/b&gt; (&lt;i&gt;SciTegic fingerprint format&lt;/i&gt;): an array of the &quot;on&quot; bits.&lt;/li&gt; 
&lt;li&gt;&lt;b&gt;List of Floating-Point Bits&lt;/b&gt;: an array of floating-point numbers.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;List of String Bits&lt;/b&gt;: an array of strings.&lt;/li&gt;
&lt;/ul&gt;
</sci:help>
						<sci:legalval>Fixed-Length Bitset</sci:legalval>
						<sci:legalval selected="true">Fixed-Length Binary String</sci:legalval>
						<sci:legalval>Fixed-Length Hex String</sci:legalval>
						<sci:legalval>Fixed-Length Array of Bits</sci:legalval>
						<sci:legalval>Fixed-Length Array of Counts</sci:legalval>
						<sci:legalval>Fixed-Length Base64</sci:legalval>
						<sci:legalval>Fixed-Length Daylight Base64</sci:legalval>
						<sci:legalval>List of Integer Bits</sci:legalval>
						<sci:legalval>List of Floating-Point Bits</sci:legalval>
						<sci:legalval>List of String Bits</sci:legalval>
					</sci:arg>
					<sci:arg name="Output Fixed Length" type="LongType" required="false" visibility="visible" multi="false">
						<sci:help>If the output format is fixed-length, you can specify that length.  If the input format is NOT fixed-length, then you MUST specify the length if the output is fixed-length.</sci:help>
						<sci:enabledscript>findsubstring(Parameter(&apos;Output Format&apos;), &apos;Fixed-Length&apos;) &gt; 0</sci:enabledscript>
						<sci:value>33</sci:value>
					</sci:arg>
					<sci:arg name="Output Bit Order" type="StringType" required="true" visibility="visible" multi="false">
						<sci:help>
We store the bits in a byte using the least-significant bit first.  If you wish the most-significant bit to 
be first, you can do that here.  

&lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;&lt;/p&gt;  
&lt;ul&gt;&lt;li&gt;Once you convert once, you do not need to do it again later.
&lt;/li&gt;&lt;/ul&gt;
</sci:help>
						<sci:legalval selected="true">Pack Least-Significant First</sci:legalval>
						<sci:legalval>Pack Most-Significant First</sci:legalval>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval selected="true">ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/chemistry</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Fri Jan 03 10:53:16 2014</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>Convert Fingerprint</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>COMPONENTNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{88776655-E6CC-49BD-82DA-EBBA9B98C905}</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>2466 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Converts a fingerprint property from one format to another</sci:value>
						<sci:value>&lt;p&gt;Converts fingerprints from one format to another.  This is useful for preparing externally-generated fingerprints for use in Pipeline Pilot.  In that case, you should convert the fingerprints to a useful internal format, such as &lt;i&gt;List of Integer Bits&lt;/i&gt;. (The format for SciTegic fingerprints such as FCFP_6 and MDLPublicKeys is &lt;i&gt;List of Integer Bits&lt;/i&gt;).&lt;/p&gt;

&lt;p&gt;You can also use this to prepare fingerprints for export to external programs.  For example, you may want to convert the fingerprints to a &lt;i&gt;Fixed-Length Array of Bits&lt;/i&gt;, which creates an array of a given size, each element either 0 or 1.&lt;/p&gt;

&lt;p&gt;When fingerprints are shrunk in size, the shrinkage is done by &lt;i&gt;folding&lt;/i&gt; the bits using a mathematical modulo (&quot;mod&quot;) operation.  Folding fingerprints generally results in a loss of information.  That is, it is possible for two non-duplicate bits to become duplicates after folding is performed.&lt;/p&gt;
</sci:value>
						<sci:value>Molecule</sci:value>
						<sci:value>Data Record with one property containing fingerprint data</sci:value>
						<sci:value>Molecule</sci:value>
						<sci:value>Data Record with one property containing fingerprint data and a new property containing the converted fingerprint.</sci:value>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon</sci:help>
						<sci:value>Convert Fingerprint</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationVersion" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The server version when this component was registered</sci:help>
						<sci:value>9.2.0.8</sci:value>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>11</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Chemistry\Data Access and Manipulation\Manipulators\Convert Fingerprint</sci:value>
					</sci:arg>
				</sci:component>
			</sci:data>
			<sci:data object="SciTegic.SDWriter.1">
				<sci:component name="SD Writer" version="2">
					<sci:arg name="Destination" type="DestinationURLType" required="true" visibility="visible" multi="false">
						<sci:help>The filename or URL for the destination data. To save in compressed (zipped) format, add the extension .gz or .zip to the filename.</sci:help>
						<sci:member>Maximum</sci:member>
						<sci:member>IfFileExists</sci:member>
						<sci:member>CharacterEncoding</sci:member>
						<sci:value>userdata:\BindingDB_actives-FRASE-triplets-v5.sdf.gz</sci:value>
					</sci:arg>
					<sci:arg name="Maximum" type="LongType" required="false" visibility="visible" multi="false">
						<sci:help>The maximum number of data records to write (all if value is empty)</sci:help>
					</sci:arg>
					<sci:arg name="IfFileExists" type="StringType" required="true" visibility="visible" multi="false">
						<sci:help>What to do if the given destination file already exists</sci:help>
						<sci:legalval selected="true">Overwrite</sci:legalval>
						<sci:legalval>Append</sci:legalval>
						<sci:legalval>Halt</sci:legalval>
					</sci:arg>
					<sci:arg name="CharacterEncoding" type="StringType" required="false" visibility="visible" multi="false">
						<sci:help>&lt;p&gt;Indicates the character set that will be used within the file.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;ANSI&lt;/b&gt; 
is the default and specifies a character set where each character is defined by a single byte.  This 
allows the Latin-1 (ISO-8859-1) character set to be written to the file.  Virtually all applications 
can read these files.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;UTF-8&lt;/b&gt; specifies a variable length character 
set.  Each character is represented by 1 to 6 bytes.  This allows writing out all extended characters 
specified in the Unicode character sets while maintaining reasonably lengthed files.  Many applications 
do not support UTF-8 files.&lt;/li&gt;
 
&lt;li&gt;&lt;b&gt;Unicode&lt;/b&gt; and &lt;b&gt;Unicode big 
endian&lt;/b&gt; are sets where each character is represented by exactly 2 bytes (also known as UCS-2).  
Depending on which is used will determine the order in which the bytes appear for each character. Many 
applications do not support Unicode or Unicode big endian files.&lt;/li&gt;
&lt;/ul&gt;
 
&lt;p&gt;&lt;b&gt;See 
Also&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For more information about each of these encoding styles, 
go to &lt;a href=&quot;javascript:DoLink(&apos;http://www.unicode.org/&apos;)&quot;&gt;http://www.unicode.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</sci:help>
						<sci:legalval selected="true">ANSI</sci:legalval>
						<sci:legalval>UTF-8</sci:legalval>
						<sci:legalval>Unicode</sci:legalval>
						<sci:legalval>Unicode big endian</sci:legalval>
					</sci:arg>
					<sci:arg name="SD Format Options" type="StringType" required="false" visibility="visible" multi="true" expanded="true">
						<sci:help>Options for the SD Writer:
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Write Structure&lt;/b&gt;:  Includes 
available structure information with each record.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Write Properties&lt;/b&gt;:  
Includes available property information with each record.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Write Date&lt;/b&gt;:  
Writes the current date into the file.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Write Fully Padded Lines&lt;/b&gt;:  
Writes all the fields in the Atoms and Bonds lines, padding with zeroes those fields with undefined values.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Write 
Query Info&lt;/b&gt;:  Writes out MOL-file query information and also additional SciTegic molecule query 
information to the properties of the SD record.
To read the SciTegic-specific part of this information 
back in, use a SciTegic SD Reader with the ReadQueryInfo parameter set to True. (This option writes out 
substructure queries that may have come from SMARTS queries. It also stops writing query information 
for viewers that cannot handle it).&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Write Two Spaces In Data Header Line&lt;/b&gt;:  
When on, data headers will be &lt;TT&gt;&amp;gt&amp;nbsp&amp;nbsp&amp;ltPropName&amp;gt&lt;/TT&gt;.  
When off, data headers will be &lt;TT&gt;&quot;&amp;gt&amp;nbsp&amp;ltPropName&amp;gt&quot;&lt;/TT&gt;.  
The standard does not specify how many spaces there should be. Making this option available for compatibility 
with 3rd party readers.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Wrap Long Property Lines&lt;/b&gt;:  By the CTFile 
standard property lines are limited to 200 characters.  When selected, properties longer than 200 characters 
are with newlines every 200 characters.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Skip Null Or Empty String Properties&lt;/b&gt;:  
When selected, properties that are either null or empty strings will be skipped upon SD export.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Write 
Dot For Empty String Properties&lt;/b&gt;:  In the CTFile format, an empty line is used to terminate 
a property value.  Because of this, there is a convention of writing a &apos;.&apos; on an empty line 
to distinguish between a property that has an empty string value (&quot;&quot;) and a property that has 
no value (or a null value).  Selecting this option enables this convention and empty string properties 
are written with a &apos;.&apos; on the first line and an empty second line to terminate the property.  
When not selected, empty string properties will be written with only a single empty terminating line 
(the same as null properties).  The default for this option is &quot;on&quot; to match the behavior in 
previous versions.  Note that empty string members of string array properties (i.e. empty lines in multi-line 
properties) will always be written with a &apos;.&apos; to prevent an empty line from terminating the 
property.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Write Templates&lt;/b&gt;:  When the molecule has SCSR sequence 
atoms that refer to residue templates, this parameter specifies whether or not to include all the template 
definitions (local and global) in a TEMPLATE block as part of the CTAB, or to include only the local 
SCSR templates, the ones that are not defined in the global templates specified by &lt;i&gt;Global Templates&lt;/i&gt; 
in the SD Reader component. The local templates always need to be saved because the SD Reader would not 
be able to read the molecule otherwise. &lt;/li&gt;
&lt;li&gt;&lt;b&gt;Convert To H2 And H+ Atom Types:&lt;/b&gt; 
&apos;H2&apos; and &apos;H+&apos; are two non-standard element types that can be assigned to atoms by 
the BIOVIA Draw sketcher. They represent unattached Hydrogen (a Hydrogen molecule) and charged Hydrogen 
(a proton), respectively. When this parameter is selected, explicit hydrogen atoms are checked to determine 
if they can be classified as &apos;H2&apos; or &apos;H+&apos; and, if so, they are written out with these 
special types instead of just &apos;H&apos;.&lt;/li&gt; 
&lt;li&gt;&lt;b&gt;Convert Pi Systems To Radicals:&lt;/b&gt; 
When checked, converts pi systems involved in pi bonds into their radical representation which is supported 
by both the V2000 and V3000 formats.  When not checked, pi bonds and pi systems are written out in V3000 
format using multiple-attachment point coordination bonds (type 9).&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Use 
2H and 3H for Hydrogen Isotopes&lt;/b&gt;: Toggles whether to explicitly write out hydrogen isotopes 
using M ISO lines in the V2000 format or MASS values in the V3000 format.  When not checked, the simpler 
&quot;D&quot; and &quot;T&quot; symbols will be used.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&amp;nbsp
&lt;/p&gt;
&lt;b&gt;V2000 
and V3000 Format Parameters&lt;/b&gt;
&lt;p&gt;
The next two options can be used to force the SD file 
format to be exclusively V2000 or V3000. If none of the options is selected, the input molecules are 
written in V2000 format unless they contain features that require the use of the V3000 format. These 
features include presence of enhanced stereo markings, more than 999 atoms or bonds, atom lists with 
more than 16 atom types or bonds of zero order (dative, coordination, hydrogen bonds). In this case, 
the output SD file might contain a mix of V2000 and V300 molecules.
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Use 
V3000 Format&lt;/b&gt;:  Force the format to be V3000 for all molecules.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;Use 
V2000 Format&lt;/b&gt;:  Force the format to be V2000 for all molecules. Any molecule with features that 
require the V3000 format is sent to the Fail port. Note that the Fail port in the SD Writer is not active 
by default. If you want to use this option, make sure to activate the component Fail port by right-clicking 
on the component and selecting the &lt;i&gt;Toggle Ports&lt;/i&gt; menu.&lt;/li&gt;
&lt;/ul&gt;</sci:help>
						<sci:legalval selected="true">Write Structure</sci:legalval>
						<sci:legalval selected="true">Write Properties</sci:legalval>
						<sci:legalval selected="true">Write Date</sci:legalval>
						<sci:legalval>Write Fully Padded Lines</sci:legalval>
						<sci:legalval selected="true">Write Query Info</sci:legalval>
						<sci:legalval>Write Two Spaces In Data Header Line</sci:legalval>
						<sci:legalval selected="true">Wrap Long Property Lines</sci:legalval>
						<sci:legalval>Skip Null Or Empty String Properties</sci:legalval>
						<sci:legalval selected="true">Write Dot For Empty String Properties</sci:legalval>
						<sci:legalval>Use V3000 Format</sci:legalval>
						<sci:legalval>Use V2000 Format</sci:legalval>
						<sci:legalval selected="true">Write Templates</sci:legalval>
						<sci:legalval>Convert To H2 And H+ Atom Types</sci:legalval>
						<sci:legalval>Convert Pi Systems To Radicals</sci:legalval>
						<sci:legalval>Use 2H and 3H for Hydrogen Isotopes</sci:legalval>
					</sci:arg>
					<sci:arg name="Additional Options" type="GroupType" required="false" visibility="visible" multi="false">
						<sci:help>Contains less commonly used parameters</sci:help>
						<sci:member>Name</sci:member>
						<sci:member>Comment</sci:member>
					</sci:arg>
					<sci:arg name="Name" type="StringType" required="false" visibility="visible" multi="false">
						<sci:help>Name of property that holds the name of each molecule</sci:help>
						<sci:value>Name</sci:value>
					</sci:arg>
					<sci:arg name="Comment" type="StringType" required="false" visibility="visible" multi="false">
						<sci:help>Name of the property that holds the comment to write in the CTAB header for each molecule</sci:help>
						<sci:value>Comment</sci:value>
					</sci:arg>
					<sci:arg name="ComponentAttributes" type="StringType" required="false" visibility="hidden" multi="true">
						<sci:help>Component Attributes</sci:help>
						<sci:legalval selected="true">ComponentTakesInput</sci:legalval>
						<sci:legalval>ComponentReturnsPass</sci:legalval>
						<sci:legalval>ComponentReturnsFail</sci:legalval>
						<sci:legalval>ComponentRunsLocal</sci:legalval>
					</sci:arg>
					<sci:arg name="OnDataTypeError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="OnGeneralError" type="StringType" required="true" visibility="hidden" multi="false">
						<sci:legalval selected="true">Halt</sci:legalval>
						<sci:legalval>Fail</sci:legalval>
						<sci:legalval>Pass</sci:legalval>
					</sci:arg>
					<sci:arg name="CustomErrorText" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="HasConvertPiSystemOption" type="BoolType" required="false" visibility="nevershow" multi="false">
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="HasWriteDotOption" type="BoolType" required="false" visibility="nevershow" multi="false">
						<sci:legalval selected="true">True</sci:legalval>
						<sci:legalval>False</sci:legalval>
					</sci:arg>
					<sci:arg name="Registrant" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The user who registered this component.</sci:help>
						<sci:value>scitegic/chemistry</sci:value>
					</sci:arg>
					<sci:arg name="RegistrationDate" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The date this component was registered.</sci:help>
						<sci:value>Tue Oct 07 13:39:57 2014</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisplayName" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>SD Writer</sci:value>
					</sci:arg>
					<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
						<sci:value>DOCUMENTNODE</sci:value>
					</sci:arg>
					<sci:arg name="ComponentGUID" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>{DC8EE7B0-0620-42FE-944C-B4CD1E79480E}</sci:value>
					</sci:arg>
					<sci:arg name="DerivedFrom" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The component this component is based upon.</sci:help>
						<sci:value>SD Writer</sci:value>
					</sci:arg>
					<sci:arg name="ComponentDisabled" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:value>0</sci:value>
					</sci:arg>
					<sci:arg name="ComponentPoint" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:value>2754 -95</sci:value>
					</sci:arg>
					<sci:arg name="ComponentHelp" type="StringType" required="false" visibility="nevershow" multi="true">
						<sci:value>100</sci:value>
						<sci:value>Writes an SD (structured data) file</sci:value>
						<sci:value>Writes the molecule and associated property data to the &lt;i&gt;Destination&lt;/i&gt; 
file in SD format.

&lt;p&gt;&lt;b&gt;See Also:&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To read files 
in SD format, use the &lt;a href=&quot;javascript:DoLink(&apos;{CA65B896-4FE6-4E3A-B884-DC16B53B8D26}&apos;)&quot;&gt;SD 
Reader&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;To convert molecules to and from a text property containing the 
molecular connection table (CTAB) in MOL format, use &lt;a href=&quot;javascript:DoLink(&apos;{E622FBD9-9FA9-451A-A102-1800B5F28B6D}&apos;)&quot;&gt;Molecule 
to CTAB&lt;/a&gt; and &lt;a href=&quot;javascript:DoLink(&apos;{7D354B65-DDD8-4EA4-83A7-21501A8A6852}&apos;)&quot;&gt;Molecule 
from CTAB&lt;/a&gt;.&lt;/li&gt; 
&lt;/ul&gt;</sci:value>
						<sci:value>Molecule</sci:value>
						<sci:value/>
						<sci:value>None</sci:value>
						<sci:value/>
						<sci:value>None</sci:value>
						<sci:value/>
					</sci:arg>
					<sci:arg name="RegistrationVersion" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The server version when this component was registered</sci:help>
						<sci:value>9.5.0.606</sci:value>
					</sci:arg>
					<sci:arg name="Component Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false"/>
					<sci:arg name="ComponentLocalID" type="LongType" required="false" visibility="nevershow" multi="false">
						<sci:help>Local Component Identifier</sci:help>
						<sci:value>40</sci:value>
					</sci:arg>
					<sci:arg name="Component Path" type="StringType" required="false" visibility="nevershow" multi="false">
						<sci:help>The original path within the database of this component.</sci:help>
						<sci:value>Components\Chemistry\Data Access and Manipulation\Writers\SD Writer</sci:value>
					</sci:arg>
				</sci:component>
			</sci:data>
			<sci:connectid from="0" to="63" type="true"/>
			<sci:connectid from="63" to="1" type="true"/>
			<sci:connectid from="1" to="2" type="true"/>
			<sci:connectid from="2" to="10" type="true"/>
			<sci:connectid from="10" to="12" type="true"/>
			<sci:connectid from="12" to="13" type="true"/>
			<sci:connectid from="13" to="14" type="true"/>
			<sci:connectid from="14" to="11" type="true"/>
			<sci:connectid from="11" to="40" type="true"/>
			<sci:version iVal="1"/>
		</sci:protocol>
	</sci:dbitem>
<!-- Exported protocol -->
<sci:component name="8.0 Protocol Warning" version="2">
<sci:arg name="ComponentIcon" type="StringType" required="true" visibility="nevershow" multi="false">
<sci:help>Component Icon</sci:help>
<sci:value>PROTOCOLNODE</sci:value>
</sci:arg>
<sci:arg name="Protocol Sticky Notes" type="StringType" required="false" visibility="nevershow" multi="false">
<sci:help>Protocol Sticky Notes</sci:help>
<sci:value>%VERSION 3%</sci:value>
<sci:value>400 -219 1222 221</sci:value>
<sci:value>250 120 20</sci:value>
<sci:value>WARNING! This is a Pipeline Pilot protocol written in version 8.0 or later. It contains features that are not supported in earlier versions of Pipeline Pilot.</sci:value>
</sci:arg>
</sci:component>
</sci:data>
